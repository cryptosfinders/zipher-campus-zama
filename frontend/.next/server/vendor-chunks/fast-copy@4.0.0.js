"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-copy@4.0.0";
exports.ids = ["vendor-chunks/fast-copy@4.0.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/fast-copy@4.0.0/node_modules/fast-copy/dist/cjs/index.cjs":
/*!***************************************************************************************!*\
  !*** ../node_modules/.pnpm/fast-copy@4.0.0/node_modules/fast-copy/dist/cjs/index.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst toStringFunction = Function.prototype.toString;\nconst toStringObject = Object.prototype.toString;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n    if (!prototype) {\n        return Object.create(null);\n    }\n    const Constructor = prototype.constructor;\n    if (Constructor === Object) {\n        return prototype === Object.prototype\n            ? {}\n            : Object.create(prototype);\n    }\n    if (Constructor &&\n        ~toStringFunction.call(Constructor).indexOf('[native code]')) {\n        try {\n            return new Constructor();\n        }\n        catch (_a) {\n            // Ignore\n        }\n    }\n    return Object.create(prototype);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nfunction getTag(value) {\n    const stringTag = value[Symbol.toStringTag];\n    if (stringTag) {\n        return stringTag;\n    }\n    const type = toStringObject.call(value);\n    return type.substring(8, type.length - 1);\n}\n\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\nfunction copyOwnDescriptor(original, clone, property, state) {\n    const ownDescriptor = Object.getOwnPropertyDescriptor(original, property) || {\n        configurable: true,\n        enumerable: true,\n        value: original[property],\n        writable: true,\n    };\n    const descriptor = ownDescriptor.get || ownDescriptor.set\n        ? ownDescriptor\n        : {\n            configurable: ownDescriptor.configurable,\n            enumerable: ownDescriptor.enumerable,\n            value: state.copier(ownDescriptor.value, state),\n            writable: ownDescriptor.writable,\n        };\n    try {\n        Object.defineProperty(clone, property, descriptor);\n    }\n    catch (_a) {\n        // The above can fail on node in extreme edge cases, so fall back to the loose assignment.\n        clone[property] = descriptor.get\n            ? descriptor.get()\n            : descriptor.value;\n    }\n}\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n    const names = Object.getOwnPropertyNames(value);\n    for (let index = 0; index < names.length; ++index) {\n        copyOwnDescriptor(value, clone, names[index], state);\n    }\n    const symbols = Object.getOwnPropertySymbols(value);\n    for (let index = 0; index < symbols.length; ++index) {\n        copyOwnDescriptor(value, clone, symbols[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    for (let index = 0; index < array.length; ++index) {\n        clone[index] = state.copier(array[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n    return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n    return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n    return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n    return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(map, clone);\n    map.forEach((value, key) => {\n        clone.set(key, state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nfunction copyObjectLoose(object, state) {\n    const clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    const symbols = Object.getOwnPropertySymbols(object);\n    for (let index = 0; index < symbols.length; ++index) {\n        const symbol = symbols[index];\n        if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = state.copier(object[symbol], state);\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n    const clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n    return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n    const clone = new state.Constructor(regExp.source, regExp.flags);\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n    return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(set, clone);\n    set.forEach((value) => {\n        clone.add(state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n\nfunction createDefaultCache() {\n    return new WeakMap();\n}\nfunction getOptions({ createCache: createCacheOverride, methods: methodsOverride, strict, }) {\n    const defaultMethods = {\n        array: strict ? copyArrayStrict : copyArrayLoose,\n        arrayBuffer: copyArrayBuffer,\n        blob: copyBlob,\n        dataView: copyDataView,\n        date: copyDate,\n        error: copySelf,\n        map: strict ? copyMapStrict : copyMapLoose,\n        object: strict ? copyObjectStrict : copyObjectLoose,\n        regExp: copyRegExp,\n        set: strict ? copySetStrict : copySetLoose,\n    };\n    const methods = methodsOverride\n        ? Object.assign(defaultMethods, methodsOverride)\n        : defaultMethods;\n    const copiers = getTagSpecificCopiers(methods);\n    const createCache = createCacheOverride || createDefaultCache;\n    // Extra safety check to ensure that object and array copiers are always provided,\n    // avoiding runtime errors.\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!copiers.Object || !copiers.Array) {\n        throw new Error('An object and array copier must be provided.');\n    }\n    return { createCache, copiers, methods, strict: Boolean(strict) };\n}\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(methods) {\n    return {\n        Arguments: methods.object,\n        Array: methods.array,\n        ArrayBuffer: methods.arrayBuffer,\n        Blob: methods.blob,\n        Boolean: copyPrimitiveWrapper,\n        DataView: methods.dataView,\n        Date: methods.date,\n        Error: methods.error,\n        Float32Array: methods.arrayBuffer,\n        Float64Array: methods.arrayBuffer,\n        Int8Array: methods.arrayBuffer,\n        Int16Array: methods.arrayBuffer,\n        Int32Array: methods.arrayBuffer,\n        Map: methods.map,\n        Number: copyPrimitiveWrapper,\n        Object: methods.object,\n        Promise: copySelf,\n        RegExp: methods.regExp,\n        Set: methods.set,\n        String: copyPrimitiveWrapper,\n        WeakMap: copySelf,\n        WeakSet: copySelf,\n        Uint8Array: methods.arrayBuffer,\n        Uint8ClampedArray: methods.arrayBuffer,\n        Uint16Array: methods.arrayBuffer,\n        Uint32Array: methods.arrayBuffer,\n        Uint64Array: methods.arrayBuffer,\n    };\n}\n\n/**\n * Create a custom copier based on custom options for any of the following:\n *   - `createCache` method to create a cache for copied objects\n *   - custom copier `methods` for specific object types\n *   - `strict` mode to copy all properties with their descriptors\n */\nfunction createCopier(options = {}) {\n    const { createCache, copiers } = getOptions(options);\n    const { Array: copyArray, Object: copyObject } = copiers;\n    function copier(value, state) {\n        state.prototype = state.Constructor = undefined;\n        if (!value || typeof value !== 'object') {\n            return value;\n        }\n        if (state.cache.has(value)) {\n            return state.cache.get(value);\n        }\n        state.prototype = Object.getPrototypeOf(value);\n        // Using logical AND for speed, since optional chaining transforms to\n        // a local variable usage.\n        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n        state.Constructor = state.prototype && state.prototype.constructor;\n        // plain objects\n        if (!state.Constructor || state.Constructor === Object) {\n            return copyObject(value, state);\n        }\n        // arrays\n        if (Array.isArray(value)) {\n            return copyArray(value, state);\n        }\n        const tagSpecificCopier = copiers[getTag(value)];\n        if (tagSpecificCopier) {\n            return tagSpecificCopier(value, state);\n        }\n        return typeof value.then === 'function'\n            ? value\n            : copyObject(value, state);\n    }\n    return function copy(value) {\n        return copier(value, {\n            Constructor: undefined,\n            cache: createCache(),\n            copier,\n            prototype: undefined,\n        });\n    };\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nconst copyStrict = createCopier({ strict: true });\n/**\n * Copy an value deeply as much as possible.\n */\nconst copy = createCopier();\n\nexports.copy = copy;\nexports.copyStrict = copyStrict;\nexports.createCopier = createCopier;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Zhc3QtY29weUA0LjAuMC9ub2RlX21vZHVsZXMvZmFzdC1jb3B5L2Rpc3QvY2pzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVDQUF1QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBcUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9yb290L3ppcGhlci1jYW1wdXMtemFtYS9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC1jb3B5QDQuMC4wL25vZGVfbW9kdWxlcy9mYXN0LWNvcHkvZGlzdC9janMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdG9TdHJpbmdGdW5jdGlvbiA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvU3RyaW5nT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8qKlxuICogR2V0IGFuIGVtcHR5IHZlcnNpb24gb2YgdGhlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3RvdHlwZSBpdCBoYXMuXG4gKi9cbmZ1bmN0aW9uIGdldENsZWFuQ2xvbmUocHJvdG90eXBlKSB7XG4gICAgaWYgKCFwcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGVcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDogT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgIH1cbiAgICBpZiAoQ29uc3RydWN0b3IgJiZcbiAgICAgICAgfnRvU3RyaW5nRnVuY3Rpb24uY2FsbChDb25zdHJ1Y3RvcikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRhZyBvZiB0aGUgdmFsdWUgcGFzc2VkLCBzbyB0aGF0IHRoZSBjb3JyZWN0IGNvcGllciBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gICAgY29uc3Qgc3RyaW5nVGFnID0gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICBpZiAoc3RyaW5nVGFnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUYWc7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0b1N0cmluZ09iamVjdC5jYWxsKHZhbHVlKTtcbiAgICByZXR1cm4gdHlwZS5zdWJzdHJpbmcoOCwgdHlwZS5sZW5ndGggLSAxKTtcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgcHJvcGVydHlJc0VudW1lcmFibGUgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBjb3B5T3duRGVzY3JpcHRvcihvcmlnaW5hbCwgY2xvbmUsIHByb3BlcnR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IG93bkRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsLCBwcm9wZXJ0eSkgfHwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBvcmlnaW5hbFtwcm9wZXJ0eV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IG93bkRlc2NyaXB0b3IuZ2V0IHx8IG93bkRlc2NyaXB0b3Iuc2V0XG4gICAgICAgID8gb3duRGVzY3JpcHRvclxuICAgICAgICA6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogb3duRGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBvd25EZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogc3RhdGUuY29waWVyKG93bkRlc2NyaXB0b3IudmFsdWUsIHN0YXRlKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBvd25EZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gVGhlIGFib3ZlIGNhbiBmYWlsIG9uIG5vZGUgaW4gZXh0cmVtZSBlZGdlIGNhc2VzLCBzbyBmYWxsIGJhY2sgdG8gdGhlIGxvb3NlIGFzc2lnbm1lbnQuXG4gICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IuZ2V0XG4gICAgICAgICAgICA/IGRlc2NyaXB0b3IuZ2V0KClcbiAgICAgICAgICAgIDogZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIFN0cmljbHR5IGNvcHkgYWxsIHByb3BlcnRpZXMgY29udGFpbmVkIG9uIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KHZhbHVlLCBjbG9uZSwgc3RhdGUpIHtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbmFtZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvcHlPd25EZXNjcmlwdG9yKHZhbHVlLCBjbG9uZSwgbmFtZXNbaW5kZXhdLCBzdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3ltYm9scy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29weU93bkRlc2NyaXB0b3IodmFsdWUsIGNsb25lLCBzeW1ib2xzW2luZGV4XSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBpbmRleGVkIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheUxvb3NlKGFycmF5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNsb25lW2luZGV4XSA9IHN0YXRlLmNvcGllcihhcnJheVtpbmRleF0sIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgaW5kZXhlZCB2YWx1ZXMgaW4gdGhlIGFycmF5LCBhcyB3ZWxsIGFzIGFueSBjdXN0b20gcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5U3RyaWN0KGFycmF5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3QoYXJyYXksIGNsb25lLCBzdGF0ZSk7XG59XG4vKipcbiAqIENvcHkgdGhlIGNvbnRlbnRzIG9mIHRoZSBBcnJheUJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoMCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBCbG9iIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weUJsb2IoYmxvYiwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRGF0YVZpZXcgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5RGF0YVZpZXcoZGF0YVZpZXcsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3Rvcihjb3B5QXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBEYXRlIGJhc2VkIG9uIHRoZSB0aW1lIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weURhdGUoZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKGRhdGUuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlNYXBMb29zZShtYXAsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IoKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChtYXAsIGNsb25lKTtcbiAgICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBjbG9uZS5zZXQoa2V5LCBzdGF0ZS5jb3BpZXIodmFsdWUsIHN0YXRlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbCBhcyBhbnkgY3VzdG9tIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNvcHlNYXBTdHJpY3QobWFwLCBzdGF0ZSkge1xuICAgIHJldHVybiBjb3B5T3duUHJvcGVydGllc1N0cmljdChtYXAsIGNvcHlNYXBMb29zZShtYXAsIHN0YXRlKSwgc3RhdGUpO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgcHJvcGVydGllcyAoa2V5cyBhbmQgc3ltYm9scykgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3RMb29zZShvYmplY3QsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBnZXRDbGVhbkNsb25lKHN0YXRlLnByb3RvdHlwZSk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQob2JqZWN0LCBjbG9uZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHN0YXRlLmNvcGllcihvYmplY3Rba2V5XSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN5bWJvbHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbHNbaW5kZXhdO1xuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCkpIHtcbiAgICAgICAgICAgIGNsb25lW3N5bWJvbF0gPSBzdGF0ZS5jb3BpZXIob2JqZWN0W3N5bWJvbF0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBwcm9wZXJ0aWVzIChrZXlzIGFuZCBzeW1ib2xzKSBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbFxuICogYXMgYW55IGhpZGRlbiBvciBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0U3RyaWN0KG9iamVjdCwgc3RhdGUpIHtcbiAgICBjb25zdCBjbG9uZSA9IGdldENsZWFuQ2xvbmUoc3RhdGUucHJvdG90eXBlKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChvYmplY3QsIGNsb25lKTtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3Qob2JqZWN0LCBjbG9uZSwgc3RhdGUpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcHJpbWl0aXZlIHdyYXBwZXIgZnJvbSB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5UHJpbWl0aXZlV3JhcHBlcihwcmltaXRpdmVPYmplY3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcihwcmltaXRpdmVPYmplY3QudmFsdWVPZigpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJlZ0V4cCBiYXNlZCBvbiB0aGUgdmFsdWUgYW5kIGZsYWdzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weVJlZ0V4cChyZWdFeHAsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IocmVnRXhwLnNvdXJjZSwgcmVnRXhwLmZsYWdzKTtcbiAgICBjbG9uZS5sYXN0SW5kZXggPSByZWdFeHAubGFzdEluZGV4O1xuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSAoYW4gaWRlbnRpdHkgZnVuY3Rpb24pLlxuICpcbiAqIEBub3RlXG4gKiBUSGlzIGlzIHVzZWQgZm9yIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgY29waWVkLCBzdWNoIGFzIFdlYWtNYXAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTZWxmKHZhbHVlLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5U2V0TG9vc2Uoc2V0LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoc2V0LCBjbG9uZSk7XG4gICAgc2V0LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGNsb25lLmFkZChzdGF0ZS5jb3BpZXIodmFsdWUsIHN0YXRlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbCBhcyBhbnkgY3VzdG9tIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTZXRTdHJpY3Qoc2V0LCBzdGF0ZSkge1xuICAgIHJldHVybiBjb3B5T3duUHJvcGVydGllc1N0cmljdChzZXQsIGNvcHlTZXRMb29zZShzZXQsIHN0YXRlKSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIG5ldyBXZWFrTWFwKCk7XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKHsgY3JlYXRlQ2FjaGU6IGNyZWF0ZUNhY2hlT3ZlcnJpZGUsIG1ldGhvZHM6IG1ldGhvZHNPdmVycmlkZSwgc3RyaWN0LCB9KSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGhvZHMgPSB7XG4gICAgICAgIGFycmF5OiBzdHJpY3QgPyBjb3B5QXJyYXlTdHJpY3QgOiBjb3B5QXJyYXlMb29zZSxcbiAgICAgICAgYXJyYXlCdWZmZXI6IGNvcHlBcnJheUJ1ZmZlcixcbiAgICAgICAgYmxvYjogY29weUJsb2IsXG4gICAgICAgIGRhdGFWaWV3OiBjb3B5RGF0YVZpZXcsXG4gICAgICAgIGRhdGU6IGNvcHlEYXRlLFxuICAgICAgICBlcnJvcjogY29weVNlbGYsXG4gICAgICAgIG1hcDogc3RyaWN0ID8gY29weU1hcFN0cmljdCA6IGNvcHlNYXBMb29zZSxcbiAgICAgICAgb2JqZWN0OiBzdHJpY3QgPyBjb3B5T2JqZWN0U3RyaWN0IDogY29weU9iamVjdExvb3NlLFxuICAgICAgICByZWdFeHA6IGNvcHlSZWdFeHAsXG4gICAgICAgIHNldDogc3RyaWN0ID8gY29weVNldFN0cmljdCA6IGNvcHlTZXRMb29zZSxcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZHMgPSBtZXRob2RzT3ZlcnJpZGVcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKGRlZmF1bHRNZXRob2RzLCBtZXRob2RzT3ZlcnJpZGUpXG4gICAgICAgIDogZGVmYXVsdE1ldGhvZHM7XG4gICAgY29uc3QgY29waWVycyA9IGdldFRhZ1NwZWNpZmljQ29waWVycyhtZXRob2RzKTtcbiAgICBjb25zdCBjcmVhdGVDYWNoZSA9IGNyZWF0ZUNhY2hlT3ZlcnJpZGUgfHwgY3JlYXRlRGVmYXVsdENhY2hlO1xuICAgIC8vIEV4dHJhIHNhZmV0eSBjaGVjayB0byBlbnN1cmUgdGhhdCBvYmplY3QgYW5kIGFycmF5IGNvcGllcnMgYXJlIGFsd2F5cyBwcm92aWRlZCxcbiAgICAvLyBhdm9pZGluZyBydW50aW1lIGVycm9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmICghY29waWVycy5PYmplY3QgfHwgIWNvcGllcnMuQXJyYXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgYW5kIGFycmF5IGNvcGllciBtdXN0IGJlIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4geyBjcmVhdGVDYWNoZSwgY29waWVycywgbWV0aG9kcywgc3RyaWN0OiBCb29sZWFuKHN0cmljdCkgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBjb3BpZXJzIHVzZWQgZm9yIGVhY2ggc3BlY2lmaWMgb2JqZWN0IHRhZy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFnU3BlY2lmaWNDb3BpZXJzKG1ldGhvZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBBcmd1bWVudHM6IG1ldGhvZHMub2JqZWN0LFxuICAgICAgICBBcnJheTogbWV0aG9kcy5hcnJheSxcbiAgICAgICAgQXJyYXlCdWZmZXI6IG1ldGhvZHMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEJsb2I6IG1ldGhvZHMuYmxvYixcbiAgICAgICAgQm9vbGVhbjogY29weVByaW1pdGl2ZVdyYXBwZXIsXG4gICAgICAgIERhdGFWaWV3OiBtZXRob2RzLmRhdGFWaWV3LFxuICAgICAgICBEYXRlOiBtZXRob2RzLmRhdGUsXG4gICAgICAgIEVycm9yOiBtZXRob2RzLmVycm9yLFxuICAgICAgICBGbG9hdDMyQXJyYXk6IG1ldGhvZHMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEZsb2F0NjRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICAgICAgSW50OEFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQxNkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQzMkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBNYXA6IG1ldGhvZHMubWFwLFxuICAgICAgICBOdW1iZXI6IGNvcHlQcmltaXRpdmVXcmFwcGVyLFxuICAgICAgICBPYmplY3Q6IG1ldGhvZHMub2JqZWN0LFxuICAgICAgICBQcm9taXNlOiBjb3B5U2VsZixcbiAgICAgICAgUmVnRXhwOiBtZXRob2RzLnJlZ0V4cCxcbiAgICAgICAgU2V0OiBtZXRob2RzLnNldCxcbiAgICAgICAgU3RyaW5nOiBjb3B5UHJpbWl0aXZlV3JhcHBlcixcbiAgICAgICAgV2Vha01hcDogY29weVNlbGYsXG4gICAgICAgIFdlYWtTZXQ6IGNvcHlTZWxmLFxuICAgICAgICBVaW50OEFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50OENsYW1wZWRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICAgICAgVWludDE2QXJyYXk6IG1ldGhvZHMuYXJyYXlCdWZmZXIsXG4gICAgICAgIFVpbnQzMkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50NjRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBjb3BpZXIgYmFzZWQgb24gY3VzdG9tIG9wdGlvbnMgZm9yIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICogICAtIGBjcmVhdGVDYWNoZWAgbWV0aG9kIHRvIGNyZWF0ZSBhIGNhY2hlIGZvciBjb3BpZWQgb2JqZWN0c1xuICogICAtIGN1c3RvbSBjb3BpZXIgYG1ldGhvZHNgIGZvciBzcGVjaWZpYyBvYmplY3QgdHlwZXNcbiAqICAgLSBgc3RyaWN0YCBtb2RlIHRvIGNvcHkgYWxsIHByb3BlcnRpZXMgd2l0aCB0aGVpciBkZXNjcmlwdG9yc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDb3BpZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjcmVhdGVDYWNoZSwgY29waWVycyB9ID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IEFycmF5OiBjb3B5QXJyYXksIE9iamVjdDogY29weU9iamVjdCB9ID0gY29waWVycztcbiAgICBmdW5jdGlvbiBjb3BpZXIodmFsdWUsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnByb3RvdHlwZSA9IHN0YXRlLkNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmNhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgLy8gVXNpbmcgbG9naWNhbCBBTkQgZm9yIHNwZWVkLCBzaW5jZSBvcHRpb25hbCBjaGFpbmluZyB0cmFuc2Zvcm1zIHRvXG4gICAgICAgIC8vIGEgbG9jYWwgdmFyaWFibGUgdXNhZ2UuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW9wdGlvbmFsLWNoYWluXG4gICAgICAgIHN0YXRlLkNvbnN0cnVjdG9yID0gc3RhdGUucHJvdG90eXBlICYmIHN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gcGxhaW4gb2JqZWN0c1xuICAgICAgICBpZiAoIXN0YXRlLkNvbnN0cnVjdG9yIHx8IHN0YXRlLkNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1NwZWNpZmljQ29waWVyID0gY29waWVyc1tnZXRUYWcodmFsdWUpXTtcbiAgICAgICAgaWYgKHRhZ1NwZWNpZmljQ29waWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnU3BlY2lmaWNDb3BpZXIodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogY29weU9iamVjdCh2YWx1ZSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29waWVyKHZhbHVlLCB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FjaGU6IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICBjb3BpZXIsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ29weSBhbiB2YWx1ZSBkZWVwbHkgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hlcmUgc3RyaWN0IHJlY3JlYXRpb24gb2Ygb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtYWludGFpbmVkLiBBbGwgcHJvcGVydGllcyAoaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMpIGFyZSBjb3BpZWQgd2l0aCB0aGVpclxuICogb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvcnMgb24gYm90aCBvYmplY3RzIGFuZCBhcnJheXMuXG4gKi9cbmNvbnN0IGNvcHlTdHJpY3QgPSBjcmVhdGVDb3BpZXIoeyBzdHJpY3Q6IHRydWUgfSk7XG4vKipcbiAqIENvcHkgYW4gdmFsdWUgZGVlcGx5IGFzIG11Y2ggYXMgcG9zc2libGUuXG4gKi9cbmNvbnN0IGNvcHkgPSBjcmVhdGVDb3BpZXIoKTtcblxuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY29weVN0cmljdCA9IGNvcHlTdHJpY3Q7XG5leHBvcnRzLmNyZWF0ZUNvcGllciA9IGNyZWF0ZUNvcGllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fast-copy@4.0.0/node_modules/fast-copy/dist/cjs/index.cjs\n");

/***/ })

};
;